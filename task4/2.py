import numpy as np

emotion_scores = [
    [0., 0.09375, 0., 0.03125, 0.125, 0., 0.40625, 0., 0.03125, 0.1875],
    [0.1, 0.2, 0.6, 0.05, 0.15, 0., 0.3, 0., 0.05, 0.1],
    [0.15, 0.8, 0.1, 0.2, 0.5, 0.05, 0.25, 0., 0.1, 0.1],
    [0.2, 0.05, 0.05, 0.1, 0., 0.05, 0.2, 0.05, 0.1, 0.1],
    [0., 0.25, 0., 0.1, 0.61, 0., 0.1, 0.1, 0., 0.1],
    [0.05, 0.2, 0.05, 0.15, 0.1, 0., 0.15, 0., 0.05, 0.1],
    [0.1, 0.15, 0., 0.05, 0.1, 0.05, 0.2, 0.1, 0.4, 0.15],
    [0.3, 0.1, 0.9, 0., 0.05, 0., 0.1, 0.1, 0.15, 0.2],
    [0.05, 0.2, 0.1, 0., 0.05, 0.05, 0.1, 0.15, 0., 0.1],
    [0., 0.1, 0., 0., 0.15, 0.2, 0.1, 0., 0., 0.1],
    [0.05, 0.1, 0.15, 0.1, 0., 0.2, 0.1, 0., 0., 0.1],
    [0., 0.15, 0.05, 0.1, 0.1, 0.8, 0.05, 0., 0.1, 0.1],
    [0.1, 0.05, 0., 0.05, 0.1, 0.1, 0.15, 0., 0.05, 0.2],
    [0.15, 0.6, 0.1, 0.1, 0.05, 0.1, 0.1, 0., 0., 0.1],
    [0.7, 0.1, 0., 0.1, 0.1, 0., 0.15, 0.1, 0., 0.1],
    [0.15, 0.2, 0.1, 0., 0.05, 0.1, 0.1, 0., 0., 0.05],
    [0.1, 0.1, 0.15, 0.1, 0., 0.15, 0.1, 0., 0., 0.1],
    [0.1, 0.15, 0.1, 0.05, 0., 0.1, 0.1, 0.05, 0.05, 0.1],
    [0.05, 0.2, 0.1, 0.81, 0.1, 0., 0.1, 0.1, 0., 0.15],
    [0., 0.1, 0.15, 0., 0.1, 0.1, 0., 0.1, 0.1, 0.1],
    [0.1, 0., 0.1, 0.15, 0.1, 0., 0.1, 0., 0., 0.1],
    [0., 0.1, 0., 0.1, 0.15, 0.1, 0.1, 0., 0., 0.91],
    [0.2, 0., 0., 0.1, 0.1, 0.1, 0.1, 0., 0.81, 0.2],
    [0.1, 0.1, 0.1, 0.1, 0., 0.1, 0., 0.71, 0.1, 0.2],
    [0., 0.1, 0., 0., 0.1, 0.1, 0.65, 0., 0.1, 0.1],
    [0.05, 0., 0.1, 0.1, 0., 0.51, 0.15, 0., 0.1, 0.1],
    [0., 0.1, 0., 0.05, 0.1, 0.1, 0.15, 0., 0., 0.1],
    [0.1, 0.1, 0., 0., 0.1, 0.1, 0., 0., 0.1, 0.15],
]

vector_w = np.random.rand(10)

# Инициализация меток
for nums in emotion_scores:
    temp = np.dot(nums[:10], vector_w)  # Используем только первые 10 параметров
    nums.append(1 if temp >= 0 else 0)

# Вывод результатов
header = "| Index | " + " | ".join([f" Param{i} " for i in range(1, 11)]) + " | Label |"
print(header)
print('-' * len(header))

for i, nums in enumerate(emotion_scores):
    print(f'| {i:<5} | ' + ' | '.join([f'{num:>8.4f}' for num in nums[:-1]]) + f' | {nums[-1]:>5}|')

# Вывод вектора весов
print("\nВектор весов:")
print(f'| {"w":<6} | ' + ' | '.join([f'{w:.4f}' for w in vector_w]) + ' |')

vector_accuracy = [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0]

# Расчет ошибок
vector_errors = []
for i in range(len(emotion_scores)):
    vector_errors.append(vector_accuracy[i] - emotion_scores[i][10])

print("vector_errors: ", vector_errors)

# Обновление векторов весов с условием выхода
max_iterations = 1000000
for iteration in range(max_iterations):
    # Обновление векторов весов
    delta_w = np.zeros(len(vector_w))

    for i in range(len(emotion_scores)):
        delta_w += vector_errors[i] * 0.01 * np.array(emotion_scores[i][:10])  # Уменьшение скорости обучения

    # Обновление векторов весов
    vector_w += delta_w

    # Обновление меток на основе новых весов
    for nums in emotion_scores:
        temp = np.dot(nums[:10], vector_w)
        nums[10] = 1 if temp >= 0 else 0

    # Расчет ошибок
    vector_errors = []
    for i in range(len(emotion_scores)):
        vector_errors.append(vector_accuracy[i] - emotion_scores[i][10])

    print("vector_errors: ", vector_errors)

    # Условие выхода
    if max(abs(np.array(vector_errors))) < 0.5:
        break

# Вывод обновленных весов
print("Обновлённые веса:")
print(vector_w)

